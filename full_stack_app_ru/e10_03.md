## Организация &laquo;большого&raquo; проекта

В современной разработке чаще всего фуллстек-фреймворки с собственной системой шаблонизации типа той, что использует django, принято считать неоптимальными. Формально в этом можно винить распространение фреймворков фронтенд-разработки и сопуствующих технологий таких как nodejs или микросервисной архитектуры. Если задача вашего контейнера просто в том чтобы по API получать данные из одного места и отправлять их в другое, нет смысла разворачивать полноценное web-приложение, можно обойтись небольшим контейнером на языке golang.

Может показаться что это означает что использование django для современной разработки это ретроградный подход, но не стоит забывать что не все web-сервисы работают в условиях сверхвысокой нагрузки или используют фронтенд в стиле Single Page Application. Во многих случаях web-интерфейс это какой-то простой способ отблегчить кому-то жизнь и не надо пытаться угнаться за модой. Если ваш web-сервис решает задачу клиента, значит он написан правильно. Не стоит бежать всё переделывать и вводить дополнительные слои абстракции только потому что кто-то сказал, что jQuery это прошлый век или что jinja2 не нужна. 

Тем не менее, есил отвлечься от шаблонов и "фронтендной" части, в django существует большое количество крутых вещей. Основная, пожалуй, это Django ORM, позволяющая гармонично получать запросы к базе данных. Также, конечно, "киллер-фичей" django является встроенная админка, хорошо настраиваемая и позволяющая быстро начать наполнять базу вашего приложения данными без больших трудностей уже на начальных этапах. Сейчас в проекте идёт большая работа по подготовке проекта к использованию современных подходов к асинхронности в python, и постепенно это должно также повысить нагрузку которую может держать django-приложения без необходимости сильно менять код.

### Организация кода моделей

Когда вы разрабатываете django-приложение достаточно долго, файлы моделей могут разрастаться до нечитаемых размеров. Конечно, свой внутренний предел по числу строк которые можно комфортно удерживать в голове у каждого программиста свой и этот предел имеет тенденцию расти с опытом, но условно когда в вашем файле больше 1000 строк это хороший сигнал поискать что в нём можно оптимизировать или вынести в отдельные компоненты. Например, можно придерживаться принципа "Одна модель &mdash; один файл", и например для блога вместо того чтобы хранить модели `Post`, `Comment` и `Author` внутри одного `models.py` сделать три файла `models/posts.py`, `models/comments.py` и `models/authors.py`. При этом если создать файл `models/__init__.py` и в нём импортировать нужные импорты этих моделей, то для разработки ничего не изменится.

Таким образом может получиться какая-то такая, например, структура:
```
project/
└── blog
    ├── admin.py
    ├── forms.py
    ├── management
    │   ├── commands
    │   │   ├── count_comments_groupby_post_and_author.py
    │   │   ├── hide_all_posts.py
    │   │   ├── __init__.py
    │   │   ├── remove_comments_by_user.py
    │   │   └── remove_comments_from_post.py
    │   └── __init__.py
    ├── models
    │   ├── authors.py
    │   ├── comments.py
    │   ├── __init__.py
    │   └── posts.py
    └── views.py
    ...
```

Содержимое файла `blog/models/__init__.py`, в обычном случае пустого, при этом можно сделать таким:
```python
from .posts import Post
from .comments import Comment
from .authors import Author
```

И тогда в коде который использует эти модели мы как и ранее сможем писать:
```python
from blog.models import Author, Comment, Post
```

При этом важно чтобы директория (благодаря нашим манипуляциям мы можем называть её "пакет") называлась именно `models`, потому на такие названия завязана внутренняя логика работы django. Дополнительное преимущество такого подхода ещё и в том, что вы, привыкая писать отдельные файлы для моделей, уменьшаете связность вашего проекта. Мы получаем в будущем хороший задел для выделения общей логики в отдельные приложения или даже сервисы.

Если ваш проект достаточно большой и у вас есть сложная логика на стороне фронтенда, можно вообще отказаться от встроенных в Django шаблонизаторов и views, сосредоточится только на базе и админке и используя django-rest-framework применять выставлять все необходимые интерфейсы как REST API для фронтенда. Как вы уже, возможно, догадались, примерно этим мы и займёмся в данном модуле.   

### Окружения разработки

Когда вашим проектом начинают пользуются реальные пользователи, вы теряете возможность ради каких-то нововведений просто выключать сервер, или на живой версии отлаживать какой-то функционал. Поэтому традиционно выделяют несколько уровней "близости" к реальным пользователям, в каждом из которых постепенно цена ошибки растёт.

В минимальном варианте у вас есть ваша локальная разработка ("dev") и "боевой" сервер ("prod"). Часто окружение для локальной разработки отличается от того, что происходит в проде: может быть другая база, отсутствовать настройки отправки писем, выключен кэш и тому подобное. По возможности в более-менее серьёзных проектах стараются вводить "pre-prod" &mdash; окружение, максимально близкое к тому, что находится "в проде", но при этом скрытое от реальных пользователях. Такое приложение обычно имеет доступ к тем же данным, что и прод (или возможно их копии) и оно может падать при каких-то работах и пестреть ошибками, но так как реальные пользователи это не видят, их можно отлаживать без негативных последствий. Также дополнительно выделяют окружение под тесты приложений, "qa" (от "quality assurance"). В подобном окружении нет никаких гарантий что что-либо будет работать, данные чаще всего могут быть любыми (например, специально такими чтобы попытаться уронить приложение) и это такая "тренировочная лаборатория" на которой проверяется, что приложение можно пускать дальше на волю.

В большинстве случаев в промышленной разработке есть хотя бы три следующих окружения: "dev" (локальная машина разработчика), "pre-prod" (окружение близкое к боевому, но недоступное пользователям), и "prod". Иногда у них другие названия, например pre-prod называют staging (это не совсем то же самое, но близок) или sandbox (тогда неявно подразумевается что в этой песочнице могут проходить какие-то тесты), но стоит стараться настроить свой проект и окружение так, чтобы выкатка очередной версии проекта на "полубоевое" окружение происходила с минимумом телодвижений. Например, в случае если pre-prod это heroku, это достигается простым git push.

### Отдельные репозитории для фронта и бэка

Если у нас богатый на взаимодействие с пользователем фронт, то это как минимум означает, что его сборка будет проходить в других условиях чем сборка бэкенда. Если над таким проектом работает несколько разработчиков, часть из которых отвечает за фронтенд, а другая за бэкенд, это может приводить к регулярным сложностям синхронизации кода, даже если использовать системы контроля версий. Поэтому часто принято разбивать разработку подобных проектов на два репозитория: под фронтенд и под бэкенд (иногда добавляют ещё третий репозиторий, где хранятся скрипты помогающие "раскатать" приложение в прод или на qa).

В такой ситуации разработчики, работающие с фронтендом, получается, могут как угодно его менять, и ориентироваться на бэкенд как на API, а разработчка бэкенда, в свою очередь, отвязана от фронтенда и обе части могут развиваться независимо, используя для решения бизнес-задач подходящие команде и сервису компоненты и методологии. Например, в такой схеме гораздо проще заменить часть сервиса другим приложением, написанном на другом языке, который например будет отвечать только на одну конкретную ручку (а маршрутизацию того, какое приложение отвечает по каким путям отдать на настройки nginx) и потом масштабировать его независимо от "основного" бэкенда.

Мониторинг у каждой части проекта при этом лучше делать свой, и дополнительно лучше избегать изменений которые нельзя быстро отключить каким-то флагом (подобный подход так и называется &mdash; используем "feature flags"). В таком случае обычно надо придерживаться аккуратной работы с данными. Например, все новые изменения в структуре базы не влияют на работу системы  (в случае Django это означает, условно, что все новые поля надо добавлять с флагом `null=True`, `blank=True` и аналогичными), а старые колонки надо удалять очень аккуратно либо в коде везде где происходит обращение к ним закладывать что в какой-то момент поля может просто не быть.